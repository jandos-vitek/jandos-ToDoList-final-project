package com.example.todolistfinalprojectjandos.Buttons;

import com.example.todolistfinalprojectjandos.OtherUIComponents.TaskMaking;
import com.example.todolistfinalprojectjandos.RepeatType;
import com.example.todolistfinalprojectjandos.Scenes.HomePage;
import com.example.todolistfinalprojectjandos.TaskRelated.ListOfTasks;
import javafx.scene.control.Button;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

import java.time.LocalDate;
import java.time.LocalDateTime;
/**
This is an abstract class used in SaveButton and UpdateButton
 It checks if the users inputs are correct
 If they are not, it shows corresponding error message
 */
public abstract class AbstractSaveButton extends Button {
    protected  ListOfTasks listOfTasks;
    protected  Stage stage;
    protected  HomePage homePage;
    protected  TaskMaking taskMaking;

    protected String name;
    protected String time;
    protected String dateString;
    protected String numberOfDays;
    protected  String description;
    protected  LocalDate date;

    protected  RepeatType repeatType;

/**
This is the constructor, the looks are deifned here
 */
    public AbstractSaveButton(ListOfTasks listOfTasks, Stage stage, TaskMaking taskMaking) {
        this.listOfTasks = listOfTasks;
        this.stage = stage;
        this.taskMaking = taskMaking;

                setStyle("""            
                -fx-background-color: rgb(0, 110, 255);
                -fx-text-fill: black;
                -fx-font-size: 25px;
                -fx-font-weight: bold;
                -fx-max-height: 50px;
                -fx-min-height: 50px;
                -fx-max-width: 140px;
                -fx-min-width: 140px;              
                -fx-background-radius: 5px;     
                """);
        setLayoutX(260);
        setLayoutY(590);
    }

    /**
     * This updates the variables, based on what user wrote in the TextField, DatePicker and others
     * It is there, so there will always be the current values
     */
    public void updateInputs(){
            name = taskMaking.getName().getText();
            time = taskMaking.getTime().getText();
            dateString = taskMaking.getDate().getEditor().getText();
            numberOfDays = taskMaking.getRepeatingMenu().getRepeatingTextField().getText();
            description = taskMaking.getDescription().getText();
            date = taskMaking.getDate().getValue();
            repeatType = taskMaking.getRepeatingMenu().getRepeatType();
    }

    /**
     * This method makes all the errors transparent, then updates all inputs
     * After that is checks if all the inputs are valid
     * @return boolean if they are valid
     */
    public boolean areInputsValid(){
        clearAllErrors();

        updateInputs();

        boolean isTimeValid = validTime(time);
        boolean isNameValid = validName(name);
        boolean isDateValid = validDate(dateString);
        boolean isNumberOfDaysValid = validDays(numberOfDays);

        return isDateValid && isNameValid && isNumberOfDaysValid && isTimeValid;
    }

    /**
     * This also checks all the inputs and then checks if the date, that user wrote isn't in past
     * It is in separate method, because it cant do anything with the date until it checks if it is written correctly
     * @return boolean if everything is correct
     */
    public boolean isEverythingValid(){
        boolean isDateInFuture = false;
        if(areInputsValid()) {
             isDateInFuture = futureDate(time, date);
        }
        return isDateInFuture;
    }

    /**
     * This makes the error messages disappear
     */
    public  void clearAllErrors() {
        taskMaking.getErrorMessages().getTimeError().setTextFill(Color.TRANSPARENT);
        taskMaking.getErrorMessages().getDateError().setTextFill(Color.TRANSPARENT);
        taskMaking.getErrorMessages().getPastError().setTextFill(Color.TRANSPARENT);
        taskMaking.getErrorMessages().getEmptyDays().setTextFill(Color.TRANSPARENT);
        taskMaking.getErrorMessages().getEmptyName().setTextFill(Color.TRANSPARENT);
    }

    /**
     * This checks if the text matches a regex, therefore if the time is written correctly
     * @param time is the String it checks
     * @return boolean if it is valid or not
     */
    public boolean validTime(String time) {
        boolean validTime = time.matches("(([0]?[0-9])|([1][0-9])|2[0-3]):[0-5][0-9]");
        if (!validTime) {
            taskMaking.getErrorMessages().getTimeError().setTextFill(Color.RED);
        }
        return validTime;
    }

    /**
     * This checks if the text matches a regex, therefore if the date is written correctly
     * THIS REGEX WAS GENERATED BY AI
     *
     * @param date is the String it checks
     * @return boolean if it is valid or not
     */
    public boolean validDate(String date) {
        boolean validDate = date.matches("^(?:(?:31/(?:0?[13578]|1[02]))|(?:29|30)/(?:0?[1,3-9]|1[0-2])|(?:0?[1-9]|1\\d|2[0-8])/0?2|(?:0?[1-9]|1\\d|2[0-8])/(?:0?[1-9]|1[0-2]))/(?:19|20)\\d{2}$");
        if (!validDate) {
            taskMaking.getErrorMessages().getDateError().setTextFill(Color.RED);
        }
        return validDate;
    }

    /**
     * This checks if the text is not empty
     * @param name is the String it checks
     * @return boolean if it is valid or not
     */
    public boolean validName(String name) {
        boolean validName = !name.trim().isEmpty();
        if (!validName) {
            taskMaking.getErrorMessages().getEmptyName().setTextFill(Color.RED);
        }
        return validName;
    }

    /**
     * This checks if the text is not empty
     * @param days is the String it checks
     * @return boolean if it is valid or not
     */
    public boolean validDays(String days) {
        boolean validDays = !days.trim().isEmpty();

        if (!validDays) {
            taskMaking.getErrorMessages().getEmptyDays().setTextFill(Color.RED);
        }
        return validDays;
    }

    /**
     * This compares the dateAndTime of the task with current dateAndTime
     * It basically stops user from creating task in the past
     * @return boolean if it is in the future (which is good)
     */
    public boolean futureDate(String time, LocalDate date) {
        LocalDateTime currentDateTime = LocalDateTime.now();
        boolean futureDate = dateAndTime(time, date).isAfter(currentDateTime);
        if (!futureDate) {
            taskMaking.getErrorMessages().getPastError().setTextFill(Color.RED);
        }
        return futureDate;
    }

    /**
     * This method puts together localDate and String and makes localDateAndTime
     *
     * @param time is the String
     * @param date is the localDate
     * @return localDateAndTime, which is then used in the task
     */
    public LocalDateTime dateAndTime(String time, LocalDate date) {
        String[] splitTime = time.split(":");
        int year = date.getYear();
        int month = date.getMonthValue();
        int day = date.getDayOfMonth();
        int hour = Integer.parseInt(splitTime[0]);
        int minute = Integer.parseInt(splitTime[1]);

        LocalDateTime dateAndTime = LocalDateTime.of(year, month, day, hour, minute);

        return dateAndTime;
    }

}
